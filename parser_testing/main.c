// Here the .dub parser, it looks to be function right now,
// look at the structs to see the format is returned in, this file is meant to turn path string into a Document object.
// The main thing missing rn is the possibility to have commands inside other commands
// File should be functional and parse a file "example.dub" in the executable directory

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

// We define length for all our arrays and strings, maybe dynamically setting this would be better at some point
#define MAX_LINES 512
#define MAX_LINE_LENGTH 2048
#define MAX_PATH_LENGTH 128
#define MAX_ELEMENT_LENGTH 4096
#define MAX_ELEMENT_AMOUNT 1024

// We use the file struct keep track of our different file attributes
struct File {
    FILE *filePtr;
    char path[MAX_PATH_LENGTH];
    char buffer[MAX_LINES];
    char *lines[MAX_LINES];
    int lineAmount;
};

// We split our document in elements
// These elements are text blocks of a certain type
// types can be anything like: text, bold text, title, formula, author, etc.
struct Element{
    char type[24];
    char content[MAX_ELEMENT_LENGTH];
};

// We use a Document struct to house all elements
struct Document{
    struct Element *elements[MAX_ELEMENT_AMOUNT];
};

// This part is ai generated by gpt4.0, cuz im lazy (; so maybe should be rewritten
void remove_newlines(char *str) {
    int readIndex = 0, writeIndex = 0;
    int startFound = 0;

    // Skip newlines at the beginning
    while (str[readIndex] == '\n') {
        ++readIndex;
    }

    // Copy the string, collapsing consecutive newlines into one
    while (str[readIndex] != '\0') {
        if (str[readIndex] != '\n' || (str[readIndex] == '\n' && startFound == 0)) {
            str[writeIndex++] = str[readIndex];
            startFound = 1; // Mark that we've started copying non-newline characters
        }

        // If we encounter a newline and the next character is not a newline, copy it
        if (str[readIndex] == '\n' && str[readIndex + 1] != '\n' && startFound == 1) {
            str[writeIndex++] = str[readIndex];
        }

        ++readIndex;
    }

    // Remove trailing newlines
    if (writeIndex > 0) { // Make sure we have written at least one character
        while (writeIndex > 0 && str[writeIndex - 1] == '\n') {
            --writeIndex;
        }
    }

    // Null-terminate the modified string
    str[writeIndex] = '\0';
}

// Here a function to print a filde directly after being read, for debugging
int printFile(struct File file){
    if(file.lines[0] == NULL){
        return 1;
    }
    for (int i = 0; i < file.lineAmount; i++) {
        printf("Line %d: %s", i + 1, file.lines[i]);
    }
    printf("\n");
    return 0;
}

struct File readFile(char path[],bool print){
    //We use File struct to keep track of all file info, handy for parallel parsing in the future
    //First we difene our file that has to bee parsed
    struct File file;
    strcpy(file.path,path);
    file.filePtr = fopen(file.path, "r");

    // Check if correctly opened
    if (file.filePtr == NULL) {
        printf("Error opening file\n");
    }

    int lineCount = 0;
    while (fgets(file.buffer, MAX_LINE_LENGTH, file.filePtr) != NULL && lineCount < MAX_LINES) {
        file.lines[lineCount] = malloc(strlen(file.buffer) + 1);
        if (file.lines[lineCount] == NULL) {
            printf("Memory allocation failed\n");
            break;
        }
        strcpy(file.lines[lineCount], file.buffer);
        lineCount++;
    }
    file.lineAmount = lineCount;

    if(print){
        printFile(file); //Printing our file for debug purposes
    }

    //close our file (tbh idk why this is neccesary, since we dont write to the file, maybe for memory management)
    fclose(file.filePtr);
    return file;
}

struct Document parseLines(struct File file){
    struct Document document;

    // We keep track of a command string to now the name of the last command called
    char command[MAX_ELEMENT_LENGTH];

    // We keep track of how many elements we appended to document, 
    // handy for indexing our elements array inside document
    int elementCount = 0;

    // We setup our buffer for holding text we iterate over, before putting that text inside an element struct. 
    char buffer[MAX_ELEMENT_LENGTH];

    // We use a int to keep track of the state of the parser when iterating over all chars
    // We assume we are looking at standard text when starting the paring, until we see a backslash
    // 0 means looking at the contents of an element
    // 1 means a command has started so we starting keeping track of the command
    // 2 means we are looking at the conctents of a command has started
    int state = 0; 

    //preample for iterating over all chars inside file.lines
    int lineCount = 0;
    char text_buffer[MAX_ELEMENT_LENGTH];
    while(lineCount < file.lineAmount){
        int charCount = 0;
        while(file.lines[lineCount][charCount] != '\0'){
            char character = file.lines[lineCount][charCount];

            // Here begins the actual parsing, we look at our state and how that character may change it
            // Why then store, free, and append the buffer to the document in the form of elements as neccesary
            if(state == 0){
                if(character == *"\\"){
                    state = 1;
                    
                    struct Element* element = malloc(sizeof(struct Element)); // Dynamically allocate memory for element
                    strcpy(element->type, "text");
                    remove_newlines(buffer);
                    strcpy(element->content, buffer);
                    document.elements[elementCount++] = element; // Store the pointer in the array
                    memset(buffer, 0, sizeof(buffer)); // Reset buffer after use

                }
                else{
                    buffer[strlen(buffer)]=character;
                }
            }
            else if(state == 1){
                if(character == *"("){
                    state = 2;
                    strcpy(command,buffer);
                    memset(buffer, 0, sizeof(buffer));
                }
                else{
                    buffer[strlen(buffer)]=character;
                }
            }
            else if(state == 2){
                if(character == *")"){
                    state = 0;
                    struct Element* element = malloc(sizeof(struct Element)); // Dynamically allocate memory for element
                    strcpy(element->type,command);
                    remove_newlines(buffer);
                    strcpy(element->content, buffer);
                    document.elements[elementCount++] = element; // Store the pointer in the array
                    memset(buffer, 0, sizeof(buffer)); // Reset buffer after use

                }
                else{
                    buffer[strlen(buffer)]=character;
                }
            }
            charCount++;
        }
        lineCount++;
    }
    // When we get to the end of our file we assume the last part to have been text,
    // if the last char is not one of our state changing chars
    struct Element* element = malloc(sizeof(struct Element)); // Dynamically allocate memory for element
    strcpy(element->type, "text");
    remove_newlines(buffer);
    strcpy(element->content, buffer);
    document.elements[elementCount++] = element; // Store the pointer in the array
    memset(buffer, 0, sizeof(buffer)); // Reset buffer after use

    

    return document;
}

struct Document parseFile(char *somepath){
    return parseLines(readFile(somepath,false));
}

int main() {
    struct Document document = parseFile("example.dub");

    // We can print the different elements for debugging purposes
    int i = 0;
    while(document.elements[i] != NULL){
        printf("Type: %s \nContent: \n%s\n--------\n",document.elements[i]->type,document.elements[i]->content);
        i++;
    }
}